<root>
  <item name="java.lang.invoke.BoundMethodHandle byte extensionIndex(char)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.BoundMethodHandle.Factory Factory()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.BoundMethodHandle.Factory java.lang.String typeSig(char)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.BoundMethodHandle.SpeciesData SpeciesData(java.lang.String)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.BoundMethodHandle.SpeciesData boolean isPlaceholder()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.BoundMethodHandle.SpeciesData int fieldCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.BoundMethodHandle.Species_L java.lang.invoke.BoundMethodHandle.SpeciesData speciesData()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.BoundMethodHandle.Species_L java.lang.invoke.MethodHandle reinvokerTarget()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.CallSite java.lang.Object maybeReBox(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.CallSite sun.invoke.empty.Empty uninitializedCallSite()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.ConstantCallSite java.lang.invoke.MethodHandle dynamicInvoker()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.ConstantCallSite java.lang.invoke.MethodHandle getTarget()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.ConstantCallSite void setTarget(java.lang.invoke.MethodHandle)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.DirectMethodHandle int afIndex(byte, boolean, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.DirectMethodHandle java.lang.Object constructorMethod(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.DirectMethodHandle java.lang.Object internalMemberName(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.DirectMethodHandle java.lang.Object staticBase(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.DirectMethodHandle java.lang.invoke.MemberName internalMemberName()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.DirectMethodHandle long fieldOffset(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.DirectMethodHandle long staticOffset(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.DirectMethodHandle.Lazy Lazy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.InvokeDynamic InvokeDynamic()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.InvokeGeneric java.lang.invoke.MethodHandles.Lookup lookup()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.InvokerBytecodeGenerator int getConstantPoolSize(byte[])">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.InvokerBytecodeGenerator.CpPatch CpPatch(java.lang.invoke.InvokerBytecodeGenerator, int, java.lang.String, java.lang.Object)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.Invokers Invokers(java.lang.invoke.MethodType)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.LambdaForm boolean permutedTypesMatch(int[], char[], java.lang.invoke.LambdaForm.Name[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm char parameterType(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm char returnType()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm double zeroD()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm float zeroF()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm int arity()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm int fixResult(int, java.lang.invoke.LambdaForm.Name[])">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm int zeroI()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm java.lang.Class&lt;?&gt; typeClass(char)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm java.lang.Object zeroL()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm java.lang.invoke.LambdaForm.Name argument(int, char)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm java.lang.invoke.LambdaForm.Name[] arguments(int, char...)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm long zeroJ()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm.Name Name(char)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.LambdaForm.Name Name(int, char)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.LambdaForm.Name Name(int, char, java.lang.invoke.LambdaForm.NamedFunction, java.lang.Object[])">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.LambdaForm.Name boolean initIndex(int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.LambdaForm.Name boolean isParam()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm.Name boolean typesMatch(char, java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm.Name char type()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm.Name int index()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm.NamedFunction NamedFunction(java.lang.invoke.MemberName)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.LambdaForm.NamedFunction NamedFunction(java.lang.invoke.MemberName, java.lang.invoke.MethodHandle)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.LambdaForm.NamedFunction boolean checkArgumentTypes(java.lang.Object[], java.lang.invoke.MethodType)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.LambdaForm.NamedFunction java.lang.Class&lt;?&gt; memberDeclaringClassOrNull()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName MemberName()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName MemberName(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Class&lt;?&gt;, byte)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MemberName MemberName(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Class&lt;?&gt;, java.lang.Void)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MemberName MemberName(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.invoke.MethodType, byte)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MemberName boolean hasReceiverTypeDispatch()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isAbstract()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isBridge()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isCallerSensitive()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isConstructor()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isField()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isFieldOrMethod()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isFinal()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isGetter()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isInvocable()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isMethod()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isMethodHandleInvoke()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isNative()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isPackage()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isPrivate()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isProtected()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isPublic()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isResolved()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isSetter()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isStatic()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isSynthetic()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isType()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isVarargs()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean isVolatile()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean staticIsConsistent()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean testAllFlags(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean testAnyFlags(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName boolean testFlags(int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName byte getReferenceKind()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName int flagsMods(int, int, byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName int getModifiers()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName java.lang.Class&lt;?&gt; getDeclaringClass()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName java.lang.String message()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName java.lang.invoke.MemberName changeReferenceKind(byte, byte)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MemberName java.lang.invoke.MemberName.Factory getFactory()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName void init(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Object, int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MemberName void initResolved(boolean)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MemberName.Factory Factory()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MemberName.Factory java.lang.invoke.MemberName[] newMemberBuffer(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandle boolean isVarargsCollector()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandle java.lang.Object internalProperties()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandle java.lang.Object internalValues()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandle java.lang.invoke.LambdaForm internalForm()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandle java.lang.invoke.MemberName internalMemberName()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandle java.lang.invoke.MethodType type()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl MethodHandleImpl()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl java.lang.invoke.MethodHandle selectAlternative(boolean, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl sun.invoke.empty.Empty throwException(T)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor ArrayAccessor()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor boolean getElementZ(boolean[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor byte getElementB(byte[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor char getElementC(char[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor double getElementD(double[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor float getElementF(float[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor int getElementI(int[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor java.lang.Object getElementL(java.lang.Object, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor java.lang.Object getElementL(java.lang.Object[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor long getElementJ(long[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.ArrayAccessor short getElementS(short[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.AsVarargsCollector boolean isVarargsCollector()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.AsVarargsCollector java.lang.invoke.MethodHandle asFixedArity()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.AsVarargsCollector java.lang.invoke.MethodHandle reinvokerTarget()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.BindCaller BindCaller()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.BindCaller.T T()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.BindCaller.T void init()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.GuardWithCatch GuardWithCatch(java.lang.invoke.MethodHandle, java.lang.Class&lt;? extends java.lang.Throwable&gt;, java.lang.invoke.MethodHandle)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MethodHandleImpl.Lazy Lazy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleInfo int getReferenceKind()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleInfo java.lang.Class&lt;?&gt; getDeclaringClass()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleInfo java.lang.String getName()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleInfo java.lang.invoke.MethodType getMethodType()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives MethodHandleNatives()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives boolean refKindDoesDispatch(byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives boolean refKindHasReceiver(byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives boolean refKindIsField(byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives boolean refKindIsGetter(byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives boolean refKindIsMethod(byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives boolean refKindIsSetter(byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives boolean refKindIsStatic(byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives boolean refKindIsValid(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives java.lang.String refKindName(byte)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleNatives.Constants Constants()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleProxies MethodHandleProxies()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleProxies boolean isWrapperInstance(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleProxies sun.invoke.WrapperInstance asWrapperInstance(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleStatics MethodHandleStatics()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleStatics java.lang.RuntimeException newIllegalArgumentException(java.lang.String)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandleStatics java.lang.RuntimeException newIllegalStateException(java.lang.String)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandles MethodHandles()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandles java.lang.invoke.MethodHandles.Lookup publicLookup()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandles.Lookup Lookup(java.lang.Class&lt;?&gt;, int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MethodHandles.Lookup boolean isFullPowerLookup()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandles.Lookup int fixmods(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandles.Lookup int lookupModes()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandles.Lookup java.lang.Class&lt;?&gt; lookupClass()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodHandles.Lookup java.lang.Class&lt;?&gt; lookupClassOrNull()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType MethodType()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MethodType boolean hasPrimitives()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType boolean isCastableTo(java.lang.invoke.MethodType)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType int parameterCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType int parameterSlotCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType int parameterSlotDepth(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType int returnSlotCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.Class&lt;?&gt; lastParameterType()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.Class&lt;?&gt; parameterType(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.Class&lt;?&gt; returnType()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.Class&lt;?&gt; rtype()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.Class&lt;?&gt;[] ptypes()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.invoke.Invokers invokers()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.invoke.MethodType basicType()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.invoke.MethodType erase()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType java.lang.invoke.MethodTypeForm form()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType void setForm(java.lang.invoke.MethodTypeForm)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MethodType.WeakInternSet WeakInternSet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MethodType.WeakInternSet int hash(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType.WeakInternSet int indexFor(int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType.WeakInternSet java.lang.invoke.MethodType.WeakInternSet.Entry[] newTable(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodType.WeakInternSet.Entry Entry(java.lang.invoke.MethodType, java.lang.ref.ReferenceQueue&lt;java.lang.Object&gt;, int, java.lang.invoke.MethodType.WeakInternSet.Entry)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.MethodTypeForm boolean hasLongPrimitives()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm boolean hasNonVoidPrimitives()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm boolean hasPrimitives()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm char unpack(long, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int argSlotToParameter(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int longPrimitiveParameterCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int longPrimitiveReturnCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int parameterCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int parameterSlotCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int parameterToArgSlot(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int primitiveParameterCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int primitiveReturnCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int returnCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm int returnSlotCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm java.lang.invoke.LambdaForm cachedLambdaForm(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm java.lang.invoke.MethodType basicType()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm java.lang.invoke.MethodType erasedType()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MethodTypeForm long pack(int, int, int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.MutableCallSite java.lang.invoke.MethodHandle getTarget()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.SwitchPoint boolean hasBeenInvalidated()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.lang.invoke.WrongMethodTypeException WrongMethodTypeException()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.WrongMethodTypeException WrongMethodTypeException(java.lang.String)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.lang.invoke.WrongMethodTypeException WrongMethodTypeException(java.lang.String, java.lang.Throwable)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
</root>
