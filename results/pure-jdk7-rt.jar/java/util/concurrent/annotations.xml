<root>
  <item name="java.util.concurrent.AbstractExecutorService AbstractExecutorService()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.AbstractExecutorService java.util.concurrent.RunnableFuture&lt;T&gt; newTaskFor(java.lang.Runnable, T)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.AbstractExecutorService java.util.concurrent.RunnableFuture&lt;T&gt; newTaskFor(java.util.concurrent.Callable&lt;T&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ArrayBlockingQueue E cast(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ArrayBlockingQueue E itemAt(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ArrayBlockingQueue int dec(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ArrayBlockingQueue int inc(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ArrayBlockingQueue void checkNotNull(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ArrayBlockingQueue.Itr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.BrokenBarrierException BrokenBarrierException()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.BrokenBarrierException BrokenBarrierException(java.lang.String)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.CancellationException CancellationException()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.CancellationException CancellationException(java.lang.String)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap java.util.Collection&lt;V&gt; values()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap java.util.Set&lt;K&gt; keySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap java.util.Set&lt;java.util.Map.Entry&lt;K,V&gt;&gt; entrySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.EntrySet EntrySet(java.util.concurrent.ConcurrentHashMap)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.HashEntry HashEntry(int, K, V, java.util.concurrent.ConcurrentHashMap.HashEntry&lt;K,V&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.HashIterator boolean hasMoreElements()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.HashIterator boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.Holder Holder()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.KeySet KeySet(java.util.concurrent.ConcurrentHashMap)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.Segment Segment(float, int, java.util.concurrent.ConcurrentHashMap.HashEntry&lt;K,V&gt;[])">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.Values Values(java.util.concurrent.ConcurrentHashMap)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentHashMap.WriteThroughEntry WriteThroughEntry(K, V)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedDeque E screenNullResult(E)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedDeque java.util.concurrent.ConcurrentLinkedDeque.Node&lt;E&gt; nextTerminator()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedDeque java.util.concurrent.ConcurrentLinkedDeque.Node&lt;E&gt; prevTerminator()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedDeque void checkNotNull(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedDeque.AbstractItr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedDeque.Node Node()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedQueue java.util.concurrent.ConcurrentLinkedQueue.Node&lt;E&gt; succ(java.util.concurrent.ConcurrentLinkedQueue.Node&lt;E&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedQueue void checkNotNull(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentLinkedQueue.Itr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap int randomLevel()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap java.lang.Comparable&lt;? super K&gt; comparable(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap java.util.Collection&lt;V&gt; values()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap java.util.Comparator&lt;? super K&gt; comparator()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap java.util.NavigableSet&lt;K&gt; keySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap java.util.NavigableSet&lt;K&gt; navigableKeySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap java.util.Set&lt;java.util.Map.Entry&lt;K,V&gt;&gt; entrySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.ComparableUsingComparator ComparableUsingComparator(K, java.util.Comparator&lt;? super K&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.EntrySet EntrySet(java.util.concurrent.ConcurrentNavigableMap&lt;K1,V1&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.HeadIndex HeadIndex(java.util.concurrent.ConcurrentSkipListMap.Node&lt;K,V&gt;, java.util.concurrent.ConcurrentSkipListMap.Index&lt;K,V&gt;, java.util.concurrent.ConcurrentSkipListMap.Index&lt;K,V&gt;, int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Index Index(java.util.concurrent.ConcurrentSkipListMap.Node&lt;K,V&gt;, java.util.concurrent.ConcurrentSkipListMap.Index&lt;K,V&gt;, java.util.concurrent.ConcurrentSkipListMap.Index&lt;K,V&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Index boolean indexesDeletedNode()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Iter boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Iter void advance()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.KeySet KeySet(java.util.concurrent.ConcurrentNavigableMap&lt;E,java.lang.Object&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Node Node(K, java.lang.Object, java.util.concurrent.ConcurrentSkipListMap.Node&lt;K,V&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Node Node(java.util.concurrent.ConcurrentSkipListMap.Node&lt;K,V&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Node V getValidValue()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Node boolean isBaseHeader()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Node boolean isMarker()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Node java.util.AbstractMap.SimpleImmutableEntry&lt;K,V&gt; createSnapshot()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.SubMap java.util.Collection&lt;V&gt; values()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.SubMap java.util.NavigableSet&lt;K&gt; keySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.SubMap java.util.NavigableSet&lt;K&gt; navigableKeySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.SubMap java.util.Set&lt;java.util.Map.Entry&lt;K,V&gt;&gt; entrySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListMap.Values Values(java.util.concurrent.ConcurrentNavigableMap&lt;java.lang.Object,E&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ConcurrentSkipListSet ConcurrentSkipListSet(java.util.concurrent.ConcurrentNavigableMap&lt;E,java.lang.Object&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList CopyOnWriteArrayList()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList E get(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList E get(java.lang.Object[], int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList int size()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList java.lang.Object[] getArray()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList java.util.Iterator&lt;E&gt; iterator()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList java.util.ListIterator&lt;E&gt; listIterator()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList void setArray(java.lang.Object[])">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWIterator COWIterator(java.lang.Object[], int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWIterator boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWIterator boolean hasPrevious()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWIterator int nextIndex()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWIterator int previousIndex()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWIterator void add(E)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWIterator void remove()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWIterator void set(E)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWSubList COWSubList(java.util.concurrent.CopyOnWriteArrayList&lt;E&gt;, int, int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWSubList void checkForComodification()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator void add(E)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator void remove()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArrayList.COWSubListIterator void set(E)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CopyOnWriteArraySet CopyOnWriteArraySet()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.CyclicBarrier int getParties()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.CyclicBarrier.Generation Generation()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.DelayQueue int remainingCapacity()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.DelayQueue.Itr E next()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.DelayQueue.Itr Itr(java.util.concurrent.DelayQueue, java.lang.Object[])">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.DelayQueue.Itr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Exchanger Exchanger()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.Exchanger.Node Node(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.Exchanger.Slot Slot()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ExecutionException ExecutionException()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ExecutionException ExecutionException(java.lang.String)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ExecutionException ExecutionException(java.lang.String, java.lang.Throwable)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ExecutorCompletionService ExecutorCompletionService(java.util.concurrent.Executor, java.util.concurrent.BlockingQueue&lt;java.util.concurrent.Future&lt;V&gt;&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ExecutorCompletionService.QueueingFuture QueueingFuture(java.util.concurrent.RunnableFuture&lt;V&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.Executors Executors()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Executors java.util.concurrent.Callable&lt;T&gt; callable(java.lang.Runnable, T)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Executors java.util.concurrent.Callable&lt;java.lang.Object&gt; callable(java.lang.Runnable)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Executors java.util.concurrent.Callable&lt;java.lang.Object&gt; callable(java.security.PrivilegedAction&lt;?&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Executors java.util.concurrent.Callable&lt;java.lang.Object&gt; callable(java.security.PrivilegedExceptionAction&lt;?&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Executors java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Executors java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Executors.DelegatedExecutorService DelegatedExecutorService(java.util.concurrent.ExecutorService)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.Executors.DelegatedScheduledExecutorService DelegatedScheduledExecutorService(java.util.concurrent.ScheduledExecutorService)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.Executors.FinalizableDelegatedExecutorService FinalizableDelegatedExecutorService(java.util.concurrent.ExecutorService)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.Executors.RunnableAdapter RunnableAdapter(java.lang.Runnable, T)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ForkJoinPool boolean getAsyncMode()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool boolean hasQueuedSubmissions()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool boolean isAtLeastTerminating()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool boolean isQuiescent()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool boolean isShutdown()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool boolean isTerminated()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool boolean isTerminating()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool int getActiveThreadCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool int getParallelism()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool int getPoolSize()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool int getQueuedSubmissionCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool int getRunningThreadCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool int idlePerActive()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool java.lang.Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory getFactory()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool java.util.concurrent.RunnableFuture&lt;T&gt; newTaskFor(java.lang.Runnable, T)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool java.util.concurrent.RunnableFuture&lt;T&gt; newTaskFor(java.util.concurrent.Callable&lt;T&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool long getQueuedTaskCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool long getStealCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool.DefaultForkJoinWorkerThreadFactory DefaultForkJoinWorkerThreadFactory()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinPool.InvokeAll InvokeAll(java.util.ArrayList&lt;java.util.concurrent.ForkJoinTask&lt;T&gt;&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ForkJoinTask ForkJoinTask()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask boolean isCancelled()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask boolean isCompletedAbnormally()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask boolean isCompletedNormally()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask boolean isDone()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask java.util.concurrent.ForkJoinTask&lt;?&gt; adapt(java.lang.Runnable)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask java.util.concurrent.ForkJoinTask&lt;T&gt; adapt(java.lang.Runnable, T)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask java.util.concurrent.ForkJoinTask&lt;T&gt; adapt(java.util.concurrent.Callable&lt;? extends T&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask.AdaptedCallable AdaptedCallable(java.util.concurrent.Callable&lt;? extends T&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ForkJoinTask.AdaptedCallable T getRawResult()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask.AdaptedCallable void setRawResult(T)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ForkJoinTask.AdaptedRunnable AdaptedRunnable(java.lang.Runnable, T)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ForkJoinTask.AdaptedRunnable T getRawResult()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinTask.AdaptedRunnable void setRawResult(T)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ForkJoinWorkerThread int getEstimatedSurplusTaskCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinWorkerThread int getPoolIndex()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinWorkerThread int getQueueSize()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinWorkerThread int nextSeed()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ForkJoinWorkerThread java.util.concurrent.ForkJoinPool getPool()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ForkJoinWorkerThread java.util.concurrent.ForkJoinTask&lt;?&gt; peekTask()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.FutureTask FutureTask(java.lang.Runnable, V)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.FutureTask FutureTask(java.util.concurrent.Callable&lt;V&gt;)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.FutureTask boolean isCancelled()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.FutureTask boolean isDone()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.FutureTask void done()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingDeque.AbstractItr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingDeque.DescendingItr java.util.concurrent.LinkedBlockingDeque.Node&lt;E&gt; firstNode()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingDeque.DescendingItr java.util.concurrent.LinkedBlockingDeque.Node&lt;E&gt; nextNode(java.util.concurrent.LinkedBlockingDeque.Node&lt;E&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingDeque.Itr java.util.concurrent.LinkedBlockingDeque.Node&lt;E&gt; firstNode()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingDeque.Itr java.util.concurrent.LinkedBlockingDeque.Node&lt;E&gt; nextNode(java.util.concurrent.LinkedBlockingDeque.Node&lt;E&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingDeque.Node Node(E)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.LinkedBlockingQueue int remainingCapacity()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingQueue int size()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingQueue.Itr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingQueue.Itr java.util.concurrent.LinkedBlockingQueue.Node&lt;E&gt; nextNode(java.util.concurrent.LinkedBlockingQueue.Node&lt;E&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedBlockingQueue.Node Node(E)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue E cast(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue E firstDataItem()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue E peek()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue LinkedTransferQueue()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue boolean hasWaitingConsumer()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue boolean isEmpty()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue int countOfMode(boolean)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue int getWaitingConsumerCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue int remainingCapacity()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue int size()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue int spinsFor(java.util.concurrent.LinkedTransferQueue.Node, boolean)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue java.util.concurrent.LinkedTransferQueue.Node firstOfMode(boolean)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue java.util.concurrent.LinkedTransferQueue.Node succ(java.util.concurrent.LinkedTransferQueue.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue.Itr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue.Node boolean cannotPrecede(boolean)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue.Node boolean isMatched()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.LinkedTransferQueue.Node boolean isUnmatchedRequest()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser boolean isTerminated()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser boolean onAdvance(int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser int arrivedOf(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser int getPhase()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser int getRegisteredParties()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser int partiesOf(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser int phaseOf(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser int unarrivedOf(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser java.util.concurrent.Phaser getParent()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser java.util.concurrent.Phaser getRoot()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Phaser java.util.concurrent.atomic.AtomicReference&lt;java.util.concurrent.Phaser.QNode&gt; queueFor(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.PriorityBlockingQueue int remainingCapacity()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.PriorityBlockingQueue java.util.Comparator&lt;? super E&gt; comparator()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.PriorityBlockingQueue.Itr E next()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.PriorityBlockingQueue.Itr Itr(java.util.concurrent.PriorityBlockingQueue, java.lang.Object[])">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.PriorityBlockingQueue.Itr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.RecursiveAction RecursiveAction()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.RecursiveAction java.lang.Void getRawResult()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.RecursiveAction void setRawResult(java.lang.Void)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.RecursiveTask RecursiveTask()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.RecursiveTask V getRawResult()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.RecursiveTask void setRawResult(V)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.RejectedExecutionException RejectedExecutionException()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.RejectedExecutionException RejectedExecutionException(java.lang.String)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.RejectedExecutionException RejectedExecutionException(java.lang.String, java.lang.Throwable)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor boolean getRemoveOnCancelPolicy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor java.util.concurrent.BlockingQueue&lt;java.lang.Runnable&gt; getQueue()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor java.util.concurrent.RunnableScheduledFuture&lt;V&gt; decorateTask(java.lang.Runnable, java.util.concurrent.RunnableScheduledFuture&lt;V&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor java.util.concurrent.RunnableScheduledFuture&lt;V&gt; decorateTask(java.util.concurrent.Callable&lt;V&gt;, java.util.concurrent.RunnableScheduledFuture&lt;V&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor void setRemoveOnCancelPolicy(boolean)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue int remainingCapacity()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue void setIndex(java.util.concurrent.RunnableScheduledFuture, int)">
    <annotation name="org.jetbrains.annotations.ParamChange" params="0"/>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr Itr(java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue, java.util.concurrent.RunnableScheduledFuture[])">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr boolean hasNext()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr java.lang.Runnable next()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask boolean isPeriodic()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.Semaphore boolean isFair()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue E peek()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue SynchronousQueue()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.SynchronousQueue SynchronousQueue(boolean)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.SynchronousQueue T[] toArray(T[])">
    <annotation name="org.jetbrains.annotations.ParamChange" params="0"/>
  </item>
  <item name="java.util.concurrent.SynchronousQueue boolean contains(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue boolean isEmpty()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue boolean remove(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue boolean removeAll(java.util.Collection&lt;?&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue boolean retainAll(java.util.Collection&lt;?&gt;)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue int remainingCapacity()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue int size()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue java.lang.Object[] toArray()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue java.util.Iterator&lt;E&gt; iterator()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue void clear()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.FifoWaitQueue FifoWaitQueue()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.LifoWaitQueue LifoWaitQueue()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferQueue TransferQueue()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferQueue.QNode QNode(java.lang.Object, boolean)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferQueue.QNode boolean isCancelled()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferQueue.QNode boolean isOffList()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferStack TransferStack()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferStack boolean isFulfilling(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferStack boolean shouldSpin(java.util.concurrent.SynchronousQueue.TransferStack.SNode)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferStack.SNode SNode(java.lang.Object)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.TransferStack.SNode boolean isCancelled()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.Transferer Transferer()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.SynchronousQueue.WaitQueue WaitQueue()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadLocalRandom int next(int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ThreadLocalRandom void setSeed(long)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor boolean allowsCoreThreadTimeOut()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor boolean isRunning(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor boolean isRunningOrShutdown(boolean)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor boolean isShutdown()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor boolean isTerminated()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor boolean isTerminating()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor boolean runStateAtLeast(int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor boolean runStateLessThan(int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor int ctlOf(int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor int getCorePoolSize()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor int getMaximumPoolSize()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor int runStateOf(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor int workerCountOf(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor java.util.concurrent.BlockingQueue&lt;java.lang.Runnable&gt; getQueue()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor java.util.concurrent.RejectedExecutionHandler getRejectedExecutionHandler()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor java.util.concurrent.ThreadFactory getThreadFactory()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor void afterExecute(java.lang.Runnable, java.lang.Throwable)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor void beforeExecute(java.lang.Thread, java.lang.Runnable)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor void onShutdown()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor void setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor void setThreadFactory(java.util.concurrent.ThreadFactory)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor void terminated()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor.AbortPolicy AbortPolicy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy CallerRunsPolicy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy DiscardOldestPolicy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor.DiscardPolicy DiscardPolicy()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.ThreadPoolExecutor.DiscardPolicy void rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit TimeUnit(java.lang.String, int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.TimeUnit long convert(long, java.util.concurrent.TimeUnit)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit long toDays(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit long toHours(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit long toMicros(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit long toMillis(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit long toMinutes(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit long toNanos(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit long toSeconds(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeUnit long x(long, long, long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.TimeoutException TimeoutException()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.TimeoutException TimeoutException(java.lang.String)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
</root>
