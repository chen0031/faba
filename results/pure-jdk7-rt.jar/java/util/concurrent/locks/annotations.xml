<root>
  <item name="java.util.concurrent.locks.AbstractOwnableSynchronizer AbstractOwnableSynchronizer()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractOwnableSynchronizer java.lang.Thread getExclusiveOwnerThread()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractOwnableSynchronizer void setExclusiveOwnerThread(java.lang.Thread)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer AbstractQueuedLongSynchronizer()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean apparentlyFirstQueuedIsExclusive()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean findNodeFromTail(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean hasContended()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean hasQueuedThreads()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean isHeldExclusively()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean isQueued(java.lang.Thread)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean tryAcquire(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean tryRelease(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer boolean tryReleaseShared(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer int getQueueLength()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer java.lang.Thread fullGetFirstQueuedThread()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer java.lang.Thread getFirstQueuedThread()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer long getState()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer long tryAcquireShared(long)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer void setHead(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
    <annotation name="org.jetbrains.annotations.ParamChange" params="0"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer void setState(long)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject ConditionObject(java.util.concurrent.locks.AbstractQueuedLongSynchronizer)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject boolean isOwnedBy(java.util.concurrent.locks.AbstractQueuedLongSynchronizer)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node Node()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node Node(java.lang.Thread, int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node Node(java.lang.Thread, java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node boolean isShared()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node predecessor()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer AbstractQueuedSynchronizer()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean apparentlyFirstQueuedIsExclusive()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean findNodeFromTail(java.util.concurrent.locks.AbstractQueuedSynchronizer.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean hasContended()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean hasQueuedThreads()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean isHeldExclusively()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedSynchronizer.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean isQueued(java.lang.Thread)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean owns(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean tryAcquire(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean tryRelease(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer boolean tryReleaseShared(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer int getQueueLength()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer int getState()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer int tryAcquireShared(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer java.lang.Thread fullGetFirstQueuedThread()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer java.lang.Thread getFirstQueuedThread()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer void setHead(java.util.concurrent.locks.AbstractQueuedSynchronizer.Node)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
    <annotation name="org.jetbrains.annotations.ParamChange" params="0"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer void setState(int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject ConditionObject(java.util.concurrent.locks.AbstractQueuedSynchronizer)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject boolean isOwnedBy(java.util.concurrent.locks.AbstractQueuedSynchronizer)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer.Node Node()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer.Node Node(java.lang.Thread, int)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer.Node Node(java.lang.Thread, java.util.concurrent.locks.AbstractQueuedSynchronizer.Node)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer.Node boolean isShared()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.AbstractQueuedSynchronizer.Node java.util.concurrent.locks.AbstractQueuedSynchronizer.Node predecessor()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.LockSupport LockSupport()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantLock ReentrantLock()">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.ReentrantLock ReentrantLock(boolean)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.ReentrantLock boolean isFair()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantLock java.util.concurrent.locks.Condition newCondition()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantLock.FairSync FairSync()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantLock.NonfairSync NonfairSync()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantLock.Sync Sync()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantLock.Sync java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject newCondition()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock boolean isFair()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock readLock()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock writeLock()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.NonfairSync boolean writerShouldBlock()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock ReadLock(java.util.concurrent.locks.ReentrantReadWriteLock)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock java.util.concurrent.locks.Condition newCondition()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.Sync int exclusiveCount(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.Sync int sharedCount(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.Sync java.lang.IllegalMonitorStateException unmatchedUnlockException()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.Sync java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject newCondition()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock WriteLock(java.util.concurrent.locks.ReentrantReadWriteLock)">
    <annotation name="org.jetbrains.annotations.LocalEffect"/>
  </item>
  <item name="java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock java.util.concurrent.locks.Condition newCondition()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val name="pure" val="true"/>
    </annotation>
  </item>
</root>
